![image](https://user-images.githubusercontent.com/46469385/106538450-914cb300-653f-11eb-8d9c-c2bf6be5e147.png)

문제 조건

1. 모든 원소는 0, 1이다.

2. 입력으로 주어지는 배열의 각 열이 가진 1의 개수와 새롭게 만드는 배열의 각 열의 1의 개수는 같다.

3. 각 행의 1의 개수는 짝수이다.

## IDEA : 시간복잡도 O(N^2 * M)

dp[column][num] = arr[0 ~ n][0 ~ column]까지 1,2번 조건을 만족하면서 num개의 행이 짝수인 배열을 만들 수 있는 경우의 수

dp[column][num]에서 arr배열의 column+1 열을 추가하면 `dp[column+1][nextNum]`을 만들 수 있다. 

dp[column][num]에서 알 수 있는 값들은 짝수 행(행들 중에 1의 개수가 짝수개인 행. 반대의 경우 홀수행)의 개수, dp[column][num] 값이다.

만약 짝수행의 column+1열에 1을 추가하는 경우 해당 짝수행은 홀수 행이 될 것이고, 홀수행의 column+1열에 1을 추가하는 경우 짝수 행이 될 것이다.

이제 짝수행들(num개) 중 k개의 행에 1을 추가한다고 가정해보자.

열 하나를 추가해서 새롭게 만들어지는 배열은 몇 개의 짝수행을 가지고 있을 것인가. 그리고 만들 수 있는 경우의 수는 어떻게 될까.


* 기존에 가지고 있던 짝수행의 개수는 num개 였고 k개의 행에 1을 추가한다고 했기 때문에 k개의 행이 홀수행이 될 것이고 남은 num-k개가 여전히 짝수행일 것이다. 
    * 이 경우의 수는 기존 짝수행의 개수 num개 중 k개를 넣을 것이기 때문에 조합 (num)C(k) 이다.

* 기존에 가지고 있던 홀수행은 n-num개(전체 배열의 행 크기 - 짝수 행 크기) 일 것이다. 
    * 조건 2에 의해 입력배열에서 column+1 열의 1의 개수를 알 수 있고 이를 oneCnt라 하자. 
    * oneCnt 중 k개는 짝수행에 넣을 것이고 남은 oneCnt - k개의 1을 홀수행에 넣을 것이다. 따라서 oneCnt-k개가 짝수행이 될 것이다. 
    * 이 경우의 수는 기존 홀수행의 개수 n-num개 중 oneCnt - k개를 넣을 것이기 때문에 조합 (n-num)C(oneCnt-k)가 될 것이다. 

위와 같이 짝수행, 홀수행의 경우를 독립사건으로 보고 각자의 경우의 수를 구했으면 두 경우의 수를 곱한 결과에 dp[column][num]을 곱한 결과가 dp[column+1][(num-k) + (oneCnt-k)] 값이 된다.

## 코드

```java
```

> 참고 : https://withhamit.tistory.com/445
